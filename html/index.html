<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sorting Algorithms</title>
    <link href='../css/bootstrap.min.css' rel='stylesheet'>
    <link href='../css/style.css' rel='stylesheet'>
</head>
<body>
<div id="container">
    <div id="options_container">
        <div>
            <label for="first_algorithm_select">Algorithm</label>
            <select id="first_algorithm_select" class='form_control'></select>
            <label for="second_algorithm_select">Algorithm</label>
            <select id="second_algorithm_select" class='form_control'></select>
        </div>
        <div>
            <label for="elements_count_select">Elements Count</label>
            <input id="elements_count_select" class='form_control' type='number' value="50" step="10" min="10"
                   max="200"/>
        </div>
        <div>
            <label for='array_type_select'>Array type</label>
            <select id='array_type_select' class='form_control'></select>
        </div>
        <div>
            <label for='interval_select'>Interval (ms)</label>
            <input id='interval_select' class='form_control' type='number' value="500" step="250" min="250" max="2000"/>
        </div>
        <div>
            <button class='btn btn-lg btn-primary' id='start_btn'>Start</button>
        </div>
        <div>
            <button class='btn btn-lg btn-primary' id='stop_btn' disabled="disabled">Stop</button>
        </div>
        </br>
        <label style="background-color: rgb(0, 0, 255); color: white;">&nbsp;&nbsp;Selected Element&nbsp;&nbsp;</label>
        <label style="background-color: rgb(0, 153, 255); color: white;">&nbsp;&nbsp;Compared Element&nbsp;&nbsp;</label>
        <label style="background-color: rgb(34, 255, 0);">&nbsp;&nbsp;Swaped Elements&nbsp;&nbsp;</label>
        <label style="background-color: rgb(255, 0, 0);">&nbsp;&nbsp;Element to Insert Into&nbsp;&nbsp;</label>
        <label style="background-color: rgb(187, 187, 0);">&nbsp;&nbsp;Element to Insert From&nbsp;&nbsp;</label>
        <label style="background-color: rgb(160, 0, 192); color: white;">&nbsp;&nbsp;Temp Value&nbsp;&nbsp;</label>
    </div>
    <div id="algorithm_elements_container">
        <div class="element_container" id="first_algorithm_div">
        </div>
        <div class="element_container" id="second_algorithm_div">
        </div>
    </div>
    <div id="informations_container">
        <div class="info_container" id="first_alg_description_div">
        </div>
        <div class="info_container" id="second_alg_description_div">
        </div>
    </div>

</div>
<div id="pseudocodes_container">
    <div id="bubblesort_pseudocode_container">
        <p id="bubblesort_main_for">&nbsp;&nbsp;&nbsp;&nbsp;for i = 0 to n-1</p>
        <p id="bubblesort_inner_for">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for j = i + 1 to n</p>
        <p id="bubblesort_compare">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if array[i] > array[j]</p>
        <p id="bubblesort_swap">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap( array[i], array[j] )</p>
        <p id="bubblesort_end_compare">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end if</p>
        <p id="bubblesort_end_inner_for">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end for</p>
        <p id="bubblesort_end_main_for">&nbsp;&nbsp;&nbsp;&nbsp;end for</p>
    </div>
    <div id="selectionsort_pseudocode_container">
        <p id="selectionsort_main_for">&nbsp;&nbsp;&nbsp;&nbsp;for i = 0 to n-1</p>
        <p id="selectionsort_take_min_key">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min_key = i</p>
        <p id="selectionsort_inner_for">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for j = i + 1 to n</p>
        <p id="selectionsort_compare">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if array[min_key] > array[j]</p>
        <p id="selectionsort_change_min_key">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min_key = j</p>
        <p id="selectionsort_end_compare">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end if</p>
        <p id="selectionsort_end_inner_for">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end for</p>
        <p id="selectionsort_swap">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap( array[min_key], array[i] )</p>
        <p id="selectionsort_end_main_for">&nbsp;&nbsp;&nbsp;&nbsp;end for</p>
    </div>
    <div id="quicksort_pseudocode_container">
        <p id="quicksort_partition">&nbsp;&nbsp;&nbsp;&nbsp;function partition(array, pivot, left, right)</p>
        <p id="quicksort_partition_take_partition_index">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;partitionIndex = left</p>
        <p id="quicksort_partition_for">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i = left to right</p>
        <p id="quicksort_partition_compare">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if array[pivot] > array[i]</p>
        <p id="quicksort_partition_inner_swap">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap( array[i], array[partitionIndex] )</p>
        <p id="quicksort_partition_increase_partition_index">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;partitionIndex++</p>
        <p id="quicksort_partition_end_id">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end if</p>
        <p id="quicksort_partition_end_for">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end for</p>
        <p id="quicksort_partition_main_swap">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap( array[right], array[partitionIndex])</p>
        <p id="quicksort_partition_return">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return partitionIndex</p>
        <p id="quicksort_partition_end">&nbsp;&nbsp;&nbsp;&nbsp;end function</p>
        <br>
        <p id="quicksort_func_">&nbsp;&nbsp;&nbsp;&nbsp;function quicksort(array, left, right)</p>
        <p id="quicksort_func_compare">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if left < right</p>
        <p id="quicksort_func_take_partition_index">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;partitionIndex = partition(array, right, left, right)</p>
        <p id="quicksort_func_first_recursive">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quicksort(array, left, partitionIndex - 1)</p>
        <p id="quicksort_func_second_recursive">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quicksort(array, partitionIndex + 1, right)</p>
        <p id="quicksort_func_end_if">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end if</p>
        <p id="quicksort_func_end">&nbsp;&nbsp;&nbsp;&nbsp;end function</p>
    </div>
    <div id="shellsort_pseudocode_container">
        <p id="shellsort_take_gap">&nbsp;&nbsp;&nbsp;&nbsp;gap = round(array.length / 2)</p>
        <p id="shellsort_main_while">&nbsp;&nbsp;&nbsp;&nbsp;while gap > 0</p>
        <p id="shellsort_for">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i = gap to array.lenght</p>
        <p id="shellsort_take_temp">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp = array[i]</p>
        <p id="shellsort_take_j">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j = i</p>
        <p id="shellsort_inner_while">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while j >= gap and array[j - gap] > temp</p>
        <p id="shellsort_inner_insert">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array[j] = array[j - gap]</p>
        <p id="shellsort_calc_j">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j = j - gap</p>
        <p id="shellsort_inner_while_end">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end while</p>
        <p id="shellsort_main_insert">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array[j] = temp</p>
        <p id="shellsort_for_end">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end for</p>
        <p id="shellsort_calc_gap">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gap = round(gap / 2)</p>
        <p id="shellsort_main_while_end">&nbsp;&nbsp;&nbsp;&nbsp;end while</p>
    </div>
    <div id="insertationsort_pseudocode_container">
        <p id="insertationsort_main_for">&nbsp;&nbsp;&nbsp;&nbsp;for i = 1 to array.length</p>
        <p id="insertationsort_take_temp">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp = array[i]</p>
        <p id="insertationsort_inner_for">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for j = i - 1 to j >= 0 and array[j] > temp</p>
        <p id="insertationsort_inner_insert">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array[j+1] = array[j]</p>
        <p id="insertationsort_end_inner_for">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end for</p>
        <p id="insertationsort_main_insert">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array[j+1] = temp</p>
        <p id="insertationsort_end_main_for">&nbsp;&nbsp;&nbsp;&nbsp;end for</p>
    </div>
    <div id="heapsort_pseudocode_container">
        <p id="heapsort_heapify">function heapify(array, heap_size, start)</p>
        <p id="heapsort_heapify_take_left">left = start * 2 + 1</p>
        <p id="heapsort_heapify_take_right">right = start * 2 + 2</p>
        <p id="heapsort_heapify_take_largest">largest = start</p>
        <p id="heapsort_heapify_first_if">if left < heap_size and array[left] > array[largest]</p>
        <p id="heapsort_heapify_first_if_take_largest">largest = left</p>
        <p id="heapsort_heapify_end_first_if">end if</p>
        <p id="heapsort_heapify_second_if">if right < heap_size and array[right] > array[largest]</p>
        <p id="heapsort_heapify_second_if_take_largest">largest = right</p>
        <p id="heapsort_heapify_end_second_if">end if</p>
        <p id="heapsort_heapify_third_if">if largest != start</p>
        <p id="heapsort_heapify_swap">swap(array[start], array[largest])</p>
        <p id="heapsort_heapify_call_recursive">heapyfy(array, heap_size, largest)</p>
        <p id="heapsort_heapify_end_third_if">end if</p>
        <p id="heapsort_heapify_end">end function</p>
        </br>
        <p id="heapsort_build_heap">function build_heap(array, heap_size)</p>
        <p id="heapsort_build_heap_for">for i = array.length / 2 to 0 inclusive</p>
        <p id="heapsort_build_heap_call_heapify">heapify(array, heap_size, i)</p>
        <p id="heapsort_build_heap_end_for">end for</p>
        <p id="heapsort_build_heap_end">end function</p>
        </br>
        <p id="heapsort_func">function heapsort(array)</p>
        <p id="heapsort_func_call_build_heap">build_heap(array, array.length)</p>
        <p id="heapsort_func_for">for i = array.length - 1 to 0</p>
        <p id="heapsort_func_swap">swap(array[0], array[i])</p>
        <p id="heapsort_func_call_heapify">heapify(i, 0)</p>
        <p id="heapsort_func_end_for">end for</p>
        <p id="heapsort_func_end_function">end function</p>
    </div>
</div>
<div id="descriptions_container">
    <p id="bubblesort_descriptions_container">&nbsp;&nbsp;&nbsp;&nbsp;Bubble sort, sometimes referred to as sinking sort, is a simple sorting algorithm that repeatedly steps through the list to be
        sorted, compares each pair of adjacent items and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is
        sorted.</p>
    <p id="selectionsort_descriptions_container">&nbsp;&nbsp;&nbsp;&nbsp;Selection sort is a sorting algorithm that divides the input list into two parts: the sublist of items already sorted, which is
        built up from left to right at the front (left) of the list, and the sublist of items remaining to be sorted that occupy the rest of the list. Initially, the sorted sublist is empty and the
        unsorted sublist is the entire input list. The algorithm proceeds by finding the smallest (or largest, depending on sorting order) element in the unsorted sublist, exchanging (swapping) it
        with the leftmost unsorted element (putting it in sorted order), and moving the sublist boundaries one element to the right.</p>
    <p id="quicksort_descriptions_container">&nbsp;&nbsp;&nbsp;&nbsp;Quicksort is a divide and conquer algorithm in the style of merge sort. The basic idea is to find a “pivot” item in the array to
        compare all other items against, then shift items such that all of the items before the pivot are less than the pivot value and all the items after the pivot are greater than the pivot value.
        After that, recursively perform the same operation on the items before and after the pivot.</p>
    <p id="shellsort_description_container">&nbsp;&nbsp;&nbsp;&nbsp;Shellsort, also known as Shell sort or Shell's method, is an in-place comparison sort. It can be seen as either a generalization of
        sorting by exchange (bubble sort) or sorting by insertion (insertion sort). The method starts by sorting pairs of elements far apart from each other, then progressively reducing the gap
        between elements to be compared. Starting with far apart elements, it can move some out-of-place elements into position faster than a simple nearest neighbor exchange.</p>
    <p id="insertationsort_description_container">&nbsp;&nbsp;&nbsp;&nbsp;Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. At each iteration,
        insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.</p>
    <p id="heapsort_description_container">&nbsp;&nbsp;&nbsp;&nbsp;Heapsort is a comparison-based sorting algorithm. Heapsort can be thought of as an improved selection sort: like that algorithm, it
        divides its input into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by extracting the largest element and moving that to the sorted region. The improvement
        consists of the use of a heap data structure rather than a linear-time search to find the maximum.</p>
</div>
<div id="performances_container">
    <div id="bubblesort_performance_container">
        <p>Worst-case performance: O(n<sup>2</sup>)</p>
        <p>Best-case performance: O(n)</p>
        <p>Average performance: O(n<sup>2</sup>)</p>
        <p></p>
    </div>
    <div id="selectionsort_performance_container">
        <p>Worst-case performance: O(n<sup>2</sup>)</p>
        <p>Best-case performance: O(n<sup>2</sup>)</p>
        <p>Average performance: O(n<sup>2</sup>)</p>
        <p></p>
    </div>
    <div id="quicksort_performance_container">
        <p>Worst-case performance: O(n<sup>2</sup>)</p>
        <p>Best-case performance: O(nlogn)</p>
        <p>Average performance: O(nlogn)</p>
        <p></p>
    </div>
    <div id="shellsort_performance_container">
        <p>Worst-case performance: O(nlog<sup>2</sup>n)</p>
        <p>Best-case performance: O(nlogn)</p>
        <p>Average performance: O(nlogn)</p>
        <p></p>
    </div>
    <div id="insertationsort_performance_container">
        <p>Worst-case performance: O(n<sup>2</sup>)</p>
        <p>Best-case performance: O(n)</p>
        <p>Average performance: O(n<sup>2</sup>)</p>
        <p></p>
    </div>
    <div id="heapsort_performance_container">
        <p>Worst-case performance: O(nlogn</p>
        <p>Best-case performance: O(nlogn)</p>
        <p>Average performance: O(nlogn)</p>
        <p></p>
    </div>
</div>
</body>
<script src='../js/jquery-3.2.1.min.js'></script>
<script src='../js/bootstrap.min.js'></script>
<script type="text/javascript" src="../js/main_script.js"></script>
</html>